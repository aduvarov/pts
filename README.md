# Пишем функцию с `generics

### Проблемы без дженериков:

-   [x] Пример из Go: отсутствие дженериков усложняло работу.
-   [x] Без дженериков: необходимость использовать any приводит к потере типизации.

### Пример использования без дженериков:

1. Создание функции `logMiddleware` для логирования данных разных типов.
2. Сначала для `number`, затем расширение до `string` и `union type`.
3. Ввод `any` как финального решения приводит к потере типизации результата.

### Введение в дженерики:

-   [x] Дженерики позволяют создавать универсальные функции, работающие с любыми типами данных.
-   [x] Пример: функция логирования `logMiddleware`, способная обрабатывать разные типы данных без потери типизации результата.

### Основные особенности дженериков:

1. Обозначение дженериков при помощи угловых скобок и обычно буквы `T`.
2. Возможность использования любого имени для дженерика, хотя общеприняты краткие имена.
3. Дженерики улучшают типизацию путём сохранения типа данных сквозь функции.

### Примеры дженериков в действии:

#### 1. Функция разделения массива пополам:

-   [x] Первый пример показывает, как параметризовать функцию дженериком для работы с массивами разных типов.

#### 2. Практические аспекты:

-   [x] Дженерики требуют точных ограничений (например, работа с массивами), для корректной работы.
-   [x] Пример с функцией `splitHalf`: демонстрация ограничения дженерика для работы только с массивами.
